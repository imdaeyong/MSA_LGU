강사명: 인경열
공유: https://github.com/inky4832/


1일차
가. 환경설정

  JDK ( 1.8 )
  https://www.oracle.com/kr/java/technologies/javase/javase-jdk8-downloads.html

  STS ( sts 3.9.14 , eclipse 4.15)
  https://spring.io/tools

  h2
  https://www.h2database.com/html/main.html

  스프링부트 프로젝트 생성
  https://start.spring.io/

# 리뷰 내용
1. 빌드 툴(maven)
   pom.xml 파일에 의존성 설정.

   http://mvnrepository.com

2. SpringBoot의 환경설정 파일

   application.properties
   application.yml

   예> server.port=8081

3.  내장 톰캣 사용
   spring-boot-starter-web


4. 추가되는 컴포넌트(빈)는 
반드시 @SpringBootApplication 로 지정된
  Application파일의 패키지의 서브패키지 형태로 
  설정해야 된다.

  ==> 추가되는 컴포넌트들이 생성된다.
  ==> 마킹 어노테이션
      @RestController
      @Controller
      @Service
      @Repository
      @Component
      ..
    
5. 요청 URL
  http://localhost:8081/컨텍스트명/서블릿맵핑/hello
 =>http://localhost:8081/hello
localhost:  호스트 ip번호
 8081   : 톰캣 port번호 ( 기본:8080)
   변경가능?
   application.properties
   (key=value  설정)
   에서
   server.port=8081

컨텍스트명: 현재 지정안됨.
    server.servlet.context-path=/aaa

서블릿맵핑: 스프링에서는 DispatchServlet 자동지원.  
        서블릿 맵핑값은 /로 자동지정되어있음.

hello : Controller클래스의 
        @RequestMapping("/hello") 일치.
	요청매핑값: /hello
	
최종적으로 기억해야되는 URL?
http://localhost:8081/컨텍스트명/서블릿맵핑/요청매핑/자원


6. Controller 클래스
  역할: 웹브라우저가 요청시 가장 entry point 역할

  가. @Controller
      ==> 실행결과를 html(JSP)로 반환시
      ==> 필요시 실행결과를 데이터(text, JSON, XML )로 반환하려면
         추가로 @ResponseBody 어노테이션이 필요하다.

  나. @RestController (*****)
      ==> 실행결과를 데이터(text, JSON, XML )로 반환시
      ==> @Controller + @ResponseBody 포함한 기능

     *Controller 에서 반환값에 따라서 데이터가 달라진다.
       a. public List<String> hello() 
         ==> 화면에 JSON의 배열형식으로 반환
	   예> ["홍길동","이순신",...]
       b. public String  hello()
       ==> 화면에 문자열 형식으로 반환

       c. public User  hello()
       ==> 화면에 JSON의 객체형식으로 반환

           {
		"name": "홍길동",
		"age": 20
	   }

       d. public List<User>  hello()
       ==> 화면에 JSON의 객체형식으로 반환
	   [
		{
		"name": "홍길동1",
		"age": 30
		},
		{
		"name": "홍길동2",
		"age": 20
		}
	    ]
7. DI(Dependency Injection: 의존성 주입)
  ==> 임의의 A에서 B 사용

  가. 생성자 이용 주입 (*****, 자사에서 사용)
    ==> HelloService 반드시 사용하는 의도 내포
   @RestController
public class HelloController {
	private HelloService service;
	// 생성자 이용하여 주입 받는다.
	public HelloController(HelloService service) {
		this.service = service;
	}
	
  나. @Autowired 주입
==> HelloService 반드시 사용하는 의도가 덜함
   @RestController
public class HelloController {
	
	@Autowired(required=false)
	private HelloService service;


8. 웹 어플리케이션 개발 방법
 가. SOAP 서비스
    ==> 일반적인 웹 어플리케이션 방법
    ==> 요청방법
        가. get 방식
	  ==> 사용자가 입력한 데이터(파라미터)가
	     URL 포함되어 전달
	     http://localhost:8080/searchUser?id=1234&pw=9876

	나. post 방식
          ==> 사용자가 입력한 데이터(파라미터)가
	     URL 포함되지 않고 body 숨겨서 전달
	     http://localhost:8080/searchUser
	
	     body: id=1234&pw=9876
    ==> 응답 ( 화면이 있는 html,jsp 형태 )

       
 나. RESTful 서비스 (*****)
     ==> 사용자가 입력한 데이터(파라미터)를 url에 포함해서 요청
      http://localhost:8080/요청매핑/id/1234/pw/9876

      http://localhost:8080/요청매핑/ + 넘겨줄 데이터를 JSON
      
    ==> method 사용하여 의도를 내포                   스프링의 Controller
      가. get :   select 의도  ================>  @GetMapping , @RequestMapping(value="/aa", method=RequestMethod.GET)
      나. post:   insert 의도  ================>  @PostMapping  , @RequestMapping(value="/aa", method=RequestMethod.POST) 
      다. put :   update 의도  ================>  @PutMapping  , @RequestMapping(value="/aa", method=RequestMethod.PUT)
      라. delete:  delete 의도  ================> @DeleteMapping  , @RequestMapping(value="/aa", method=RequestMethod.DELETE)

   ==> 응답 ( JSON, XML 형태 )
   ==> JSON응답받으려면 @RestController(@Controller+@ResponseBody)  

         1)URL요청   @RestController
   브라우저 --------> Controller
         <-------
	   JSON 응답

   @ResponseBody 역할:  자바클래스를 JSON 형태로 변경해주는 역할 
   @RequestBody  역할:  JSON를 자바클래스를 형태로 변경해주는 역할
                      도구(Swagger API, 크롬브라우저의 Postman 확장팩, curl) 활용하여 JSON을 넘긴다.

          1)json요청   @RestController
   브라우저 -------->    Controller   2)@RequestBody 처리
         <-------
	  3) JSON 응답


9.  lombok 라이브러리
   
    ==> DTO,VO 클래스의 setter,getter메서드, 생성자 자동 생성

    가. lombok.jar 실행
       c:/> java -jar 경로/lombok.jar
      
    나. 창이 보이면 sts.ext 설정하고 install 한다.

    다. sts 재시작하고 project/clean 한다.

    라. @Data 같은 어노테이션 사용 가능.



10. @Response 역할
   ==> 서버에서 실행된 자바클래스를 JSON 변환하여 반환
   ==> @Controller + @Response 형식
   ==> @RestController 형식

11. @RequestBody 역할
   ==>  클라이언트에서 요청한 JSON 식을  자바클래스로 변환
   ==> @RestController 형식
   public String createCust(@RequestBody
       Customer customer )

   public class Customer {
	private String userid;
	private String passwd;
	//반드시 getter/setter, 기본 생성자 필수
   }
   JSON:
   {
      "userid":"aaa", // Customer 클래스의 변수명과 동일
      "passwd":"1234"

   }

12. (RESTful 서비스 방식중에서) 클라이언트에서 서버로 데이터 전달방법 2가지

  가. http://localhost:8080/요청매핑/id/1234/pw/9876   ==> 도구 불필요
     http://localhost:8080/요청매핑/id/8888/pw/7654

     @PathVariable 로 값을 얻는다.

     http://localhost:8080/xxx/id/1234/pw/9876
     예>
       @GetMapping("/xxx/id/{a}/pw/{b})
       public String hello(@PathVariable  String a, @PathVariable String b)

  나. http://localhost:8080/요청매핑/ + 넘겨줄 데이터를 JSON  ==> 도구 필요(Swagger API, Postman)
 

13. 전체 아키텍쳐(********************)
                                      @Transactional 
                @RestController       @Service              @Repository
브라우저 --------> Controler -----------> Service ------------> Repository -----> DB
      <-------            <----------          <-----------            
       JSON응답                          DTO(User)<------------> @Entity, @Id
                                                              JPA영속성객체(엔티티)= emp테이블(pk)
									       dept테이블
									       ...
    DTO ----> Entity
    Entity --> DTO    변경 작업이 필요하다. ( ModelMapper, mapstruct 라이브러리 )
//Entity ==> DTO
	public OrderDTO toOrderDTO(OrderEntity order) {
		if(order == null) {
			return null;
		}
		
		//Builder패턴
		OrderDTO dto = OrderDTO.builder()
						.name(order.getName())
						.createDate(order.getCreateDate())
						.orderId(order.getOrderId())
						.productId(order.getProductId())
						.quantity(order.getQuantity())
						.totalPrice(order.getTotalPrice())
						.unitPrice(order.getUnitPrice())
						.userId(order.getUserId())
						.build();
		
		return dto;
		
	}
	
	// List<Entity> ==> List<DTO>
	public List<OrderDTO> toOrderDTOList(List<OrderEntity> orders){
		if(orders == null) {
			return null;
		}
		
		List<OrderDTO> list = new ArrayList<OrderDTO>(orders.size());
		for(OrderEntity order : orders) {
			list.add(toOrderDTO(order));
		}
		return list;
	}

//////////////////////////////////////////////////////////////////////
JPA(Java Persistence API)
 ==> JPA는 스펙(인터페이스)이고
     구현체는 하이버네이트(hibernate)이다.

1.JPA특징
  - SQL 대신에 자바클래스의 메서드로 DB연동
  - ORM(Object-Relational Mapping)

2. 구현 아키텍쳐

   자바클래스 +  영속성 객체(JPA 관리하는 클래스) +  DB
  
   - 영속성 객체
   - 영속성 컨텍스트
   - 영속성 객체의 라이프사이클

3. 트랜잭션(tx) 범위안에서 JPA를 사용해야 한다.

   가.  Spring 아닌 코드
	EntityManager em = ...
        em.begin();  //tx 시작
         ..
	 .. 
 
        em.commit();  //tx 종료
	
   나.  Spring 코드

      => Service 클래스에서
        @Transactional 사용 ( 메서드레벨, 클래스레벨 )
  
    예>
       public class MyService{

	  @Transactional  //메서드레벨
	  public void insert(){
             //JPA 코드
	  }
	  @Transactional
	  public void delete(){
             //JPA 코드
	  }

	  public void update(){
             
	  }

       }
        @Transactional
        public class MyService{

	    //메서드레벨
	  public void insert(){
             //JPA 코드
	  }
	  public void delete(){
             //JPA 코드
	  }

	  public void update(){
             //JPA 코드
	  }

       }

4. JPA 에서  CRUD 작업
  - SQL문이 아닌 메서드로 CRUD 작업
    가. DML
       - insert:   persist(엔티티)
       - delete:   remove(엔티티)
       - update:   엔티티.set메서드(값)

    나. Query
       - select:    find(엔티티, id값)


  - JPA에서 제공하는 JPQL 사용하면 SQL 사용 가능. ( 현 과정에서는 사용불가 )

 
5. DB 연동하기 위한 설정 정보 4가지
  가. DB 벤더에서 제공하는 jar 파일( 드라이버 )
  나. url 정보 ( DB설치 ip, port번호, 서비스명)
  다. 사용자 id
  라. 사용자 pw

  ==> Spring에서는 application.properties 설정한다.

///////////////////////////////////////////////////
SpringMVC에서는 JPA 를 편하게 사용하기 위해서 SpringData API 지원

가. 의존성 추가
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>

나. JpaRepository<Customer, String> 인터페이스 제공
  ==> 다양한 CRUD 메서드가 제공된다.